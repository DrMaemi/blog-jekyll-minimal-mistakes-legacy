---
title: '[디자인패턴] 전략(Strategy)'
author_profile: true
uml: true
toc_label: '[디자인패턴] 전략(Strategy)'
---

## 전략 패턴(Strategy Pattern)이란?
전략 패턴(Strategy Pattern), 또는 정책 패턴(Policy Pattern)은 **실행 중 알고리즘을 선택**할 수 있게 하는 패턴이며, GoF 디자인 패턴 중 행위 패턴에 속합니다.

![](https://drive.google.com/uc?export=view&id=19DPCjZybzDo_UvwYvt_nffVxkm5dsxuD){: .align-center}
&lt;그림 1. 전략 패턴 UML 클래스 다이어그램&gt;
{: style="text-align: center;"}

## 예제 - 카드 또는 계좌 결제 방법 결정
```java
public class OrderController{

    @PostMapping("/pay")
    public void pay(@RequestBody PayInfoDto payInfoDto) {
        Client client = new Client();

        client.pay(payInfoDto);
    }
}

public class Client{

    @Autowired CardDao cardDao;
    @Autowired AccountDao accountDao;
    @Autowired CardAPI cardApi;
    @Autowired AccountAPI accountApi;

    ...

    public void pay(PayInfoDto payInfoDto){

        if(PayInfoDto.type == "CARD") {
            cardDao.insertCardInfo(payInfoDto);         // 카드 정보 저장
            cardApi.pay(payInfoDto);                    // 카드 정보 기반 결제
        }
        else if(PayInfoDto.type == "ACCOUNT") {
            accountDao.insertAccountInfo(payInfoDto);   // 계좌 정보 저장
            accountApi.pay(payInfoDto);                 // 계좌 정보 기반 결제
        } 
        else {
            // 존재하지 않는 결제 타입인 경우 에러 발생
        }
    }
}
```

## 문제점
- 결제 타입으로 카드, 계좌이체 외에 인터넷 뱅킹, 신용카드, 체크카드, 휴대폰 결제 등이 계속 늘어날 경우 분기처리해야 하는 if-else 코드가 추가되어야 함. if문 내 if문이 필요해질 수 있음
    - 코드 가독성 저하
- 주어진 결제 로직이 다른 클래스에서도 사용되는 경우 코드를 그대로 복사하여 작성해야 함
    - 코드 재사용성 저하
    - 변경사항 발생 시 일괄 적용 어려움(유지보수 어려움)

## 개선 방법
주문 서비스(OrderService) 객체는 카드 결제, 계좌 이체 등의 방법을 이용하여 공통된 '결제' 서비스를 이용하므로 이에 착안하여 추상화한 결제 서비스(PayService)에 의존하도록 설계합니다. 카드 서비스(CardService)와 계좌 서비스(AccountService)가 결제 서비스를 구체화하도록 구현합니다.

{% raw %}
```java
public interface PayStrategy {

    void pay(PayInfoDto payInfoDto);
}

@Service
public class CardService implements PayStrategy {

    @Autowired CardDao cardDao;
    @Autowired CardApi cardApi;

    @Override
    public void pay(PayInfoDto payInfoDto) {
        cardDao.insertCardInfo(payInfoDto);     // 카드 정보 저장
        cardApi.pay(payInfoDto);                // 카드 정보 기반 결제
    }
}

@Service
public class AccountService implements PayStrategy {

    @Autowired AccountDao accountDao;
    @Autowired AccountApi accountApi;

    @Override
    public void pay(PayInfoDto payInfoDto) {
        accountDao.insertCardInfo(payInfoDto);  // 계좌 정보 저장
        accountApi.pay(payInfoDto);             // 카드 정보 기반 결제
    }
}

public class Client {

    private PayStrategy payStrategy;
    
    public Client(PayStrategy payStrategy) {
        this.payStrategy = payStrategy;
    }

    public void pay(PayInfoDto payInfoDto) {
        payStrategy.pay(payInfoDto);
    }
}

@RestController
public class OrderController{

    @Autowired CardService cardService;
    @Autowired AccountService accountService;

    private HashMap<String, PayStrategy> payServiceByStrategy = new HashMap<>(){{
        put("CARD", cardService);
        put("ACCOUNT", accountService);
    }};

    @PostMapping("/pay")
    public void pay(@RequestBody PayInfoDto payInfoDto) {
        Client client = new Client(payServiceByStrategy.type);

        client.pay(payInfoDto);
    }
}
```
{% endraw %}

## A. 참조
Tom, "전략패턴(Strategy Pattern)를 이용해 코드 리팩토링," *Tistory*, Feb. 13, 2020. [Online]. Available: [https://naming0617.tistory.com/33](https://naming0617.tistory.com/33) [Accessed Sep. 3, 2022].
